# class StoppableThread(threading.Thread):
#     """Thread class with a stop() method. The thread itself has to check
#     regularly for the stopped() condition."""

#     def __init__(self,  *args, **kwargs):
#         super(StoppableThread, self).__init__(*args, **kwargs)
#         self._stop_event = threading.Event()

#     def stop(self):
#         self._stop_event.set()

#     def stopped(self):
#         return self._stop_event.is_set()


################################
# def guiThread():
#     root = tk.Tk()
#     tempEvent = sg.popup_ok_cancel("Empty measurment finished.\nPlease insert substance, then press 'OK'.")
#     root.mainloop()

# def popupOkCancel(return_value_holder):
#     tempEvent = sg.popup_ok_cancel("Empty measurment finished.\nPlease insert substance, then press 'OK'.")
#     return_value_holder.return_value = tempEvent

# gui_thread = threading.Thread(target=guiThread)
    # gui_thread.start()
    # gui_thread.join()
    # return_value_holder = ReturnValueHolder()
    # thread = threading.Thread(target=popupOkCancel, args=(return_value_holder,))
    # thread.start()
    # thread.join()
    # tempEvent = return_value_holder.return_value

#############################3

    # else:
    #     try:
    #         if testProcess.is_alive() == False:

    #     except:
    #         None

# testThread.stop()
            # testThread._Thread_stop() # Not working################################################################################################## Thread.close()
            #testThread.exit() # Not working################################################################################################## Thread.close()
            
                ############################################################################# From here we start the thred of a function:
                # testThread = threading.Thread(target=theTestThread, args=(window,))
                # testThread.start()
                # ######################################################################################### End of the function to thread.

#############################
            # stop the thread
            #testThread.stop()
            #if testThread == False:     # Delete
            #    print("testThread == False")    # Delete
            # testProcess.terminate() ####### Close the thread!!!
            ################################




    #check0 = testThread.result
            #a = 2*float(values['intervalTime'])
            #print(a)
            #check1 = time.time() - timeToWaitForStop
            #check2 = testThread.result
    
    
    # waitLayout = [[sg.Text('Please wait, stopping the testing process...')]]
    # stoppingWindow = sg.Window('Stopping thest process', waitLayout)
    # time.sleep(5)
    # while testThread.result != False:
    #     print("waiting to exit")
    #     None
    # stoppingWindow.close()
    # sg.popup_ok("The test process was stopped by the user!")